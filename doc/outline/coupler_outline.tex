%        File: coupling_outline.tex
%     Created: Friday March 4 12:24:15 2011
% Last Change: Friday March 4 12:24:20 2011
%
\documentclass[letterpaper]{article}
\usepackage[top=1.0in,bottom=1.0in,left=1.0in,right=1.0in]{geometry}
\usepackage{appendix}
\usepackage{verbatim}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[usenames]{color}
\usepackage[
  naturalnames = true, 
  colorlinks = true, 
  linkcolor = black,
  anchorcolor = black,
  citecolor = black,
  menucolor = black,
  urlcolor = blue
]{hyperref}
\usepackage{listings}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
  backgroundcolor=\color{lbcolor},
  tabsize=4,
  rulecolor=,
  language=c++,
  basicstyle=\scriptsize,
  upquote=true,
  aboveskip={1.5\baselineskip},
  columns=fixed,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  prebreak =
  \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  frame=single,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  identifierstyle=\ttfamily,
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\author{Stuart R. Slattery
  \\ \href{mailto:sslattery@wisc.edu}{\texttt{sslattery@wisc.edu}}
}

\date{Wednesday, October 12 2011}
\title{Design and Implementation of the Coupling Package}
\begin{document}
\maketitle

\section{Introduction}
For most multiphysics simulations, some form of data transfer between
physics codes is required. In general, data transfer can be performed
through an ad-hoc coupling of the codes with custom software designed
for the specific simulation. However, it is useful to consider a
common framework and an associated interface for data transfer
operations. This common interface, to be fulfilled by each code that
desires to participate in coupling under this framework, should reduce
repeated effort and define generic and reusable software that can be
applied to many forms of multiphysics simulation.

The coupling package aims to define such an interface for coupling in
addition to providing concrete implementations of algorithms and
communication patterns for parallel data transfer using the
information acquired through this interface. This document discusses
the design requirements of this package, the resulting interface
specification, and the implementation of a basic transfer algorithm
using this interface. It should not be the aim of the coupling package
to eliminate other forms of multiphysics data transfer. Rather, it
should attempt to define a useful interface that provides value by
simplifying the coupling process and reducing the barrier of entry for
a physics code to participate in coupling.

This document details the design requirements for the coupling
package, its subsequent design and interfaces, and implementation
details.

\section{Design Requirements for the Coupling Package}
The coupling package should fulfill the following design
requirements:

\begin{itemize}
\item Be able to couple multiple codes that have implemented the
  interface.
\item Be independent of the underlying data structures of the physics
  codes using the interface.
\item Be aware of the potential mesh entity structures that are
  associated with the fields being transferred (i.e. vertices, faces,
  elements, etc.).
\item Be aware of the parallel communication objects that operate the
  codes being coupled.
\item Be able to generate a parallel topology map using information
  made available through the interface.
\item Be able to transfer multiple fields using the topology map and
  information made available through the interface.
\end{itemize}

\section{Preliminary Design of the Coupling Package}

\subsection{Coupling Package Interfaces}
As part of the requirements listed in the previous section, it is
necessary to define an interface for the coupling package that will
allow access to information held by each physics code being coupled in
order to meet the coupling algorithm requirements in concrete data
transfer implementations.

In its current form, the interface to the coupling package exists as
two abstract interfaces contained by the {\sl Data\_Source} and the
{\sl Data\_Target} classes. At least one of these interfaces should be
fulfilled by each physics code that desires to participate in coupling
under this framework by creating its own implementation of the {\sl
  Data\_Source} interface for supplying data to the coupling package
and the {\sl Data\_Target} interface for receiving data from the
coupling package. By implementing these, a code will provide the
necessary information to implement coupling algorithms. 

The following section provides the {\sl Data\_Source} and {\sl
  Data\_Target} abstract interfaces. All methods defined by these
interfaces are pure virtual and therefore must be defined by all
implementations. Three template parameters are defined for the
interfaces, the scalar data type to be transferred, the handle type
associated with mesh entities (commonly int or long int), and the
coordinate type for defining spatial locations (commonly double or float).

The Teuchos package of Trilinos is used for memory management,
imposing the requirement on interface implementations to use reference
counting pointers and array views. The underlying physics package need
not implement these memory management tools, however, they must
provide an interface implementation with these utilities.

Communication is handled by the Teuchos abstract communication
interface, allowing for various architectures to be supported. In the
instance of MPI-based communication, any communication implementing
MPI primitives (e.g. MPI\_SEND, MPI\_RECEIVE, etc.) can be used.

As an initial attempt to create mesh aware data structures, a simple
point object has been implemented as a container for coordinates and
an associated identifier handle within the mesh subpackage. These
interfaces also impose the requirement that this point data structure
be used in the implemenations.

The following sections outline both interfaces and details on their
requirements. 

\subsubsection{Data Source Interface}

The {\sl Data\_Source} interface consists of the following pure
virtual method to be implemented by the client application.

\paragraph{\sl Data\_Source::comm()}
This method requires the client application to return a Teuchos::RCP
to a const reference of its communicator object. For the case of an
MPI implementation, this is not required to be MPI_COMM_WORLD.

\paragraph{\sl Data\_Source::field\_supported()}
This method checks whether or not a particular field, indicated by
name with a string, is implemented for transfer by the client. Given
this string, the client should return true if the field is supported,
false if not.

\paragraph{\sl Data\_Source::get\_points()}
Given a point object, the client returns true if this point resides in
the local domain and should therefore be mapped, and false if not. As
this is the only method in the interface that supplies target points
to the source application, it is recommended that if the point handles
and/or coordinates are required by the client for data transfer, that
they be cached during the implementation of this method.

\paragraph{\sl Data\_Source::send\_data()}
For a given field identified by a string, return a const
Teuchos::ArrayView of the data corresponding to the target points
found in the local domain through the {\sl get\_points} method.

\paragraph{\sl Data\_Source::set\_global\_data()}
For a given field identified by a string, return a single global data
value.

The following listing provides the {\sl Data\_Source} abstract
interface. 

\begin{lstlisting}
  #include <string>

  #include <Mesh_Point.hpp>

  #include "Teuchos_RCP.hpp"
  #include "Teuchos_Comm.hpp" 
  #include "Teuchos_ArrayView.hpp"

  namespace coupler
  {

    template<class DataType_T, class HandleType_T, class CoordinateType_T>
    class Data_Source 
    {
      public:

      typedef DataType_T                                 DataType;
      typedef HandleType_T                               HandleType;
      typedef CoordinateType_T                           CoordinateType;
      typedef int                                        OrdinalType;
      typedef mesh::Point<HandleType,CoordinateType>     PointType;
      typedef Teuchos::Comm<OrdinalType>                 Communicator_t;
      typedef Teuchos::RCP<const Communicator_t>         RCP_Communicator;

      Data_Source()
      { /* ... */ }

      virtual ~Data_Source()
      { /* ... */ }

      virtual RCP_Communicator comm() = 0;

      virtual bool field_supported(const std::string &field_name) = 0;

      virtual bool get_points(const PointType &point) = 0;

      virtual const Teuchos::ArrayView<DataType> 
      send_data(const std::string &field_name) = 0;

      virtual DataType set_global_data(const std::string &field_name) = 0;
    };

  } // end namespace coupler
\end{lstlisting}

\subsubsection{Data Target Interface}

The {\sl Data\_Target} interface consists of the following pure
virtual method to be implemented by the client application.

\paragraph{\sl Data\_Target::comm()}
This method requires the client application to return a Teuchos::RCP
to a const reference of its communicator object. For the case of an
MPI implementation, this is not required to be MPI\_COMM\_WORLD.

\paragraph{\sl Data\_Target::field\_supported()}
This method checks whether or not a particular field, indicated by
name with a string, is implemented for transfer by the client. Given
this string, the client should return true if the field is supported,
false if not.

\paragraph{\sl Data\_Target::set\_points()}
For a given field identified by a string, return a Teuchos::Array view
of all the points to which data should be mapped in the local target
domain. All point handles are required to be globally unique.

\paragraph{\sl Data\_Target::receive\_data()}
For a given field identified by a string, return a non-const
Teuchos::ArrayView of the data vector associated with the points
provided by the {\sl set\_points} method.

\paragraph{\sl Data\_Target::get\_global\_data()}
For a given field identified by a string, a single global data value
is provided.

The following listing provides the {\sl Data\_Target} abstract
interface. 

\begin{lstlisting}
  namespace coupler
  {

    template<class DataType_T, class HandleType_T, class CoordinateType_T>
    class Data_Target 
    {
      public:

      typedef DataType_T                                 DataType;
      typedef HandleType_T                               HandleType;
      typedef CoordinateType_T                           CoordinateType;
      typedef int                                        OrdinalType;
      typedef mesh::Point<HandleType,CoordinateType>     PointType;
      typedef Teuchos::Comm<OrdinalType>                 Communicator_t;
      typedef Teuchos::RCP<const Communicator_t>         RCP_Communicator;

      Data_Target()
      { /* ... */ }

      virtual ~Data_Target()
      { /* ... */ }

      virtual RCP_Communicator comm() = 0;

      virtual bool field_supported(const std::string &field_name) = 0;

      virtual const Teuchos::ArrayView<PointType> 
      set_points(const std::string &field_name) = 0;

      virtual Teuchos::ArrayView<DataType> 
      receive_data(const std::string &field_name) = 0;

      virtual void get_global_data(const std::string &field_name,
                                   const DataType &data) = 0;
    };

  } // end namespace coupler
\end{lstlisting}

\subsection{Data Field}

The relationship between a particular {\sl Data\_Source} and {\sl
  Data\_Target} implementation is contained by the {\sl Data\_Field}
object. Both mapping and transfer operations between the {\sl
  Data\_Source} and {\sl Data\_Target} are handled by the {\sl
  Data\_Field}. The following methods are available for the {\sl
  Data\_Field} object.

\paragraph{\sl Data\_Field::Data\_Field()}
The constructor for this object requires the communicator on which to
operate. At a minimum, this should correspond to the union of the
target and source communicators. Again, for MPI implementations this
is not limited to MPI\_COMM\_WORLD. Rather, it is only required that
this communicator span the communication space that encompasses both
communicators provided by the source and target interfaces. In
addition, a string defining the name of the field, reference counting
pointers to the two interface implementations, and an optional boolean
indicating whether or not this is a scalar field. The default value of
this boolean is false, indicating that the field is distributed.

\paragraph{\sl Data\_Field::transfer()}
Transfer the data associated with the field. This method has no
arguments. 

The following listing gives an example at the driver level of how the
{\sl Data\_Field} object is used to transfer data between the two
interfaces. In this example, the scalar data type to be transferred is
double, handle type is int, and coordinate type is float.

\begin{lstlisting}
  Teuchos::RCP<Data_Source<double,int,float> > source = 
  Teuchos::rcp( new Data_Source_Implementation<double,int,float>() );

  Teuchos::RCP<Data_Target<double,int,float> > target = 
  Teuchos::rcp( new Data_Target_Implementation<double,int,float>() );

  Data_Field<double,int,float> field( MPI_COMM_WORLD, "DISTRIBUTED_FIELD", source, target ); 

  field.transfer();
\end{lstlisting}

\section{Mapping and Transfer Algorithm Implementation}



\section{Conclusion}

A supporting document has been generated outlining how to acquire and
build the coupler along with an example of how to generate a
multiphysics application using this package.

\pagebreak
\bibliographystyle{ieeetr}
\bibliography{paper}
\end{document}


