%        File: coupling_outline.tex
%     Created: Friday March 4 12:24:15 2011
% Last Change: Friday March 4 12:24:20 2011
%
\documentclass[letterpaper]{article}
\usepackage[top=1.0in,bottom=1.0in,left=1.0in,right=1.0in]{geometry}
\usepackage{appendix}
\usepackage{verbatim}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[usenames]{color}
\usepackage[
naturalnames = true, 
colorlinks = true, 
linkcolor = black,
anchorcolor = black,
citecolor = black,
menucolor = black,
urlcolor = blue
]{hyperref}
\usepackage{listings}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
  backgroundcolor=\color{lbcolor},
  tabsize=4,
  rulecolor=,
  language=c++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak =
        \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\author{Stuart R. Slattery
\\ \href{mailto:sslattery@wisc.edu}{\texttt{sslattery@wisc.edu}}
}

\date{Wednesday, October 12 2011}
\title{Outline of the Coupling Package}
\begin{document}
\maketitle

\section{Introduction}
For most multiphysics simulations, some form of data transfer between
physics codes is required. In general, data transfer can be performed
through an ad-hoc coupling of the codes with custom software designed
for the specific simulation. However, it is useful to consider a
common framework and an associated interface for data transfer
operations. This common interface, to be fulfilled by each code that
desires to participate in coupling under this framework, should reduce
repeated effort and define generic and reusable software that can be
applied to many forms of multiphysics simulation.

The coupling package aims to define such an interface for coupling in
addition to providing concrete implementations of algorithms and
communication patterns for parallel data transfer using the
information acquired through this interface. This document discusses
the design requirements of this package, the resulting interface
specification, and the implementation of a basic transfer algorithm
using this interface. It should not be the aim of the coupling package
to eliminate other forms of multiphysics data transfer. Rather, it
should attempt to define a useful interface that provides value by
simplifying the coupling process and reducing the barrier of entry for
a physics code to participate in coupling. 

\section{Design Requirements for the Coupling Package}
The coupling package should fulfill the following design
requirements:

\begin{itemize}
\item Be able to couple multiple codes that have implemented the
  interface.
\item Be independent of the underlying data structures of the physics
  codes using the interface.
\item Be aware of the potential mesh entity structures that are
  associated with the fields being transferred (i.e. vertices, faces,
  elements, etc.).
\item Be aware of the parallel communication objects that operate the
  codes being coupled.
\item Be able to generate a parallel topology map using information
  made available through the interface.
\item Be able to transfer multiple fields using the topology map and
  information made available through the interface.
\end{itemize}

\section{Preliminary Design of the Coupling Package}

\subsection{Coupling Package Interfaces}
As part of the requirements listed in the previous section, it is
necessary to define an interface for the coupling package that will
allow access to information held by each physics code being coupled in
order to meet the coupling algorithm requirements in concrete data
transfer implementations.

In its current form, the interface to the coupling package exists as
two abstract interfaces contained by the {\sl Data\_Source} and the
{\sl Data\_Target} classes. At least one of these interfaces should be
fulfilled by each physics code that desires to participate in coupling
under this framework by creating its own implementation of the {\sl
  Data\_Source} interface for supplying data to the coupling package
and the {\sl Data\_Target} interface for receiving data from the
coupling package. By implementing these, a code will provide the
necessary information to implement coupling algorithms. 

\subsubsection{Data Source Interface}

The following listing provides the {\sl Data\_Source} interface. As
noted in the listing, the Teuchos package of Trilinos is used for
memory management with the interface implementations requiring the use
of reference counting pointers and array views.

\begin{lstlisting}
#include <string>

#include <Mesh_Point.hpp>

#include "Teuchos_RCP.hpp"
#include "Teuchos_Comm.hpp"
#include "Teuchos_ArrayView.hpp"

namespace coupler
{

template<class DataType_T, class HandleType_T, class CoordinateType_T>
class Data_Source 
{
  public:

    //@{
    //! Useful typedefs.
    typedef DataType_T                                 DataType;
    typedef HandleType_T                               HandleType;
    typedef CoordinateType_T                           CoordinateType;
    typedef int                                        OrdinalType;
    typedef mesh::Point<HandleType,CoordinateType>     PointType;
    typedef Teuchos::Comm<OrdinalType>                 Communicator_t;
    typedef Teuchos::RCP<const Communicator_t>         RCP_Communicator;
    //@}

    /*!
     * \brief Constructor.
     */
    Data_Source()
    { /* ... */ }

    /*!
     * \brief Destructor.
     */
    virtual ~Data_Source()
    { /* ... */ }

    /*!
     * \brief Register communicator object.
     * \return The communicator for this physics.
     */
    virtual RCP_Communicator comm() = 0;

    /*!
     * \brief Check whether or not a field is supported. Return false if this
     * field is not supported. 
     * \param field_name The name of the field for which support is being
     * checked.
     */
    virtual bool field_supported(const std::string &field_name) = 0;

    /*! 
     * \brief Given (x,y,z) coordinates and an associated globally unique
     * handle encapsulated in a point object, return true if the point is in
     * the local domain, false if not. 
     * \param point Point to query the local domain with.
     */
    virtual bool get_points(const PointType &point) = 0;

    /*! 
     * \brief Send the field data.
     * \param field_name The name of the field to send data from.
     * \return A const view of data to be sent.
     */
    virtual const Teuchos::ArrayView<DataType> 
    send_data(const std::string &field_name) = 0;

    /*!
     * \brief Given a field, set a global data element to be be sent to a
     * target.
     * \param field_name The name of the field to send data from.
     * \return The global data element.
     */
    virtual DataType set_global_data(const std::string &field_name) = 0;
};

} // end namespace coupler
\end{lstlisting}

\subsubsection{Data Target Interface}

\subsection{Data Field}

\section{Transfer Algorithm Implementation}

\section{Conclusion}

A supporting document has been generated outlining how to acquire and
build the coupler along with an example of how to generate a
multiphysics application using this package.

\pagebreak
\bibliographystyle{ieeetr}
\bibliography{paper}
\end{document}


